4장

--------------------------------------------------------------
4-1 객체 지향과 자바
실세계 모든 것은 객체(object)다.
모든 객체들은 자신만의 고유한 특성(state)과 행동(behavior)을 가진다

1. 객체 지향 언어의 특성
 1) 캡슐화(Encapsulation)
  - 객체를 캡슐로 싸서 내부를 보호하고 볼 수 없게 하는 것
  - 객체의 가장 본질적 특징
  - 외부와의 접속을 위해 몇 부분만 공개 노출
  - 자바에선, 클래스(class)라는 캡슐, 필드(멤버 변수)와 메소드(멤버 함수)라는 내용물로 구성
   ex) class Animal {  // class (캡슐)
     String name;  // 필드
     int age;
     void eat() { ... }  // 메소드
     void speak() { ... }
   }
 2) 상속(Inheritance)
  - 자식 클래스가 부모 클래스의 속성을 물려받고 기능을 추가해 확장하는 개념
  - 부모 클래스: 슈퍼 클래스(super class)
  - 자식 클래스: 서브 클래스(sub class)
  - 슈퍼 클래스의 필드, 메소드를 물려받아 코드 재사용 > 코드 작성 시간 및 비용 절감
   ex) class Animal { ... }  // 위 캡슐화에서의 예시 참조
   class Human extends Animal {  // extends: 상속 예약어
        String hobby;
        String job;
        void work() { ... }
        void cry() { ... }  // 서브 클래스의 필드와 메소드
        // 이 외에 슈퍼 클래스의 필드와 메소드도 모두 가짐
   }
 3) 다형성(Polymorphism)
  - 동명의 메소드가 클래스 혹은 객체에 따라 다르게 동작토록 구현하는 것
  - 오버라이딩(overriding): 슈퍼 클래스에 구현된 메소드를, 서브 클래스에서 동명으로 자신에 맞게 다시 구현하는 것
  - 오버로딩(overloading): 클래스 내에서 이름이 같지만 다르게 동작하는 메소드를 여러 개 만드는 것

2. 객체 지향 언어의 목적
 - 절차 지향 언어의 단점 보완
 1) 소프트웨어의 생산성 향상
  - 소프트웨어의 시장 출현 주기 짧아짐 -> 단기간에 소프트웨어 제작 필요
   -> 소프트웨어 재사용을 위한 여러 기법을 가진 객체 지향 언어 등장
  - 상속: 기 작성된 코드를 재사용하기 쉬움(부분 수정으로 다시 코드 짜는 부담 절감)
 2) 실세계에 대한 쉬운 모델링
  - 컴퓨터가 점차 산업 전반에 활용 -> 실세계의 일을 프로그래밍하는 일 빈번
   -> 이는 절차 지향보다는 여러 객체의 상호작용인 객체 지향으로 진행하는게 낫다

--------------------------------------------------------------
4-2 자바 클래스 만들기

1. 클래스와 객체
 - 클래스: 객체를 만드는 설계도, 틀
 - 객체: 클래스대로 만들어진 실체 (클래스의 인스턴스(instance)라고도 함)

2. 클래스 구성
 - 구조 예시
public class Circle {
    public int radius;
    public String name;

    public Circle() { }
    public double getArea() {
        return 3.14 * radius * radius;
    }
}
 - class 키워드로 선언
 - 멤버: 클래스의 구성요소, 필드(멤버 변수), 메소드(멤버 함수)로 구분
 1) 클래스 선언, class Circle
  - class (클래스 이름)으로 선언
  - 중괄호 안에 멤버를 모두 작성
  - 클래스 외부엔 멤버 작성 불가(캡슐화 원칙)
 2) 접근 지정자 public
  - 접근 지정자(access specifier)
  - public: 다른 클래스에서 활용, 접근 가능함을 나타냄
  - 접근 지정자 생략 시 디폴트 접근
 3) 생성자(constructor)
  - 클래스 이름과 동일한 메소드
  - 객체 생성 시 자동 호출

3. new 연산자와 객체 생성, 그리고 레퍼런스 변수
 - 문장 예시
Circle pizza;
pizza = new Circle();
 1) 레퍼런스 변수 선언
  - 객체 생성 전, 객체를 가리킬 레퍼런스 변수를 먼저 선언
  - 해당 선언문 만으로는 객체 생성 x
 2) 객체 생성: new 연산자 이용
  - 객체가 생성되어 그 주소가 레퍼런스 변수에 대입됨
  - 레퍼런스 변수 선언과 객체 생성 동시에 가능
 3) 객체 멤버 접근
  - 객체 레퍼런스.멤버
   ex) pizza.radius, pizza.getArea()

--------------------------------------------------------------
4-3 생성자

- 생성자: 객체 생성 시 초기화를 위해 실행되는 메소드
1. 생성자 선언 및 활용
 - 구조 예시
public class Circle {
    int radius;
    String name;

    public Circle() {
        radius = 1; name = "";
    }

    public Circle(int r, String n) {
        radius = r; name = n;
    }
    ...
}
 1) 생성자 이름 == 클래스 이름
 2) 생성자는 여러 개 작성(오버로딩) 가능
 3) new 연산자로 객체 생성 시 한 번만 호출
 4) 리턴 타입 지정 불가 (void 아님)
  - 생성자 실행을 끝내고자 한다면 return 문은 사용가능

2. 기본 생성자(= 디폴트 생성자)
 - 매개변수와 실행 코드 x -> 아무 일도 하지 않고 단순 리턴
 1) 기본 생성자가 자동 생성되는 경우
  - 클래스에 생성자가 없는 경우(컴파일러가 자동으로 기본 생성자 삽입)
 2) 자동 생성되지 않는 경우
  - 클래스에 생성자가 하나라도 존재하는 경우

3. this 레퍼런스
 - 현재 실행되고 있는 메소드가 속한 객체 자신을 가리키는 레퍼런스

4. this()로 다른 생성자 호출
 - 클래스 내에서 어떤 생성자가 다른 생성자를 호출할 때 사용하는 코드
 - 용례
public class Book {
    public Book() {
        this("", "");
    }

    public Book(String title) {
        this(title, "작자 미상");
    }

    public Book(String title, String author) {
        this.title = title;
        this.author = author;
    }
}
 - 주의점
  - 반드시 생성자 코드에서만 호출 가능
  - 반드시 같은 클래스 내 다른 생성자를 호출
  - 반드시 생성자의 첫 문장

5. 객체 치환 시 주의점
Circle x = new Circle(1);
Circle y = new Circle(2);
 - 여기서 's = y'를 실행하면 y가 가리키는 객체를 s도 함께 가리킨다.
 - 그 후 'x = y'를 실행하면 원래 x가 가리키던 객체는 아무도 가리키지 않아 접근 불가
  -> 이 객체를 가비지(garbage)라고 함

--------------------------------------------------------------
4-5 메소드 활용

1. 메소드 형식
 - 접근지정자 리턴타입 메소드이름(메소드 인자들) { 내용 }
 - 접근 지정자는 public, private, protected, 디폴트 4가지

2. 인자 전달
 - 자바의 인자 전달 방식: 값에 의한 호출(call-by-value)
 1) 기본 타입의 값이 전달되는 경우
  - 호출자가 건네는 값이 매개변수에 복사되어 전달
 2) 객체가 전달되는 경우
  - 객체의 레퍼런스 값이 전달됨
 3) 배열이 전달되는 경우
  - 배열에 대한 레퍼런스 값이 전달됨

--------------------------------------------------------------
4-7 접근 지정자
 - 패키지: 서로 연관된 클래스 파일들을 저장해 관리하는 것 (= 디렉터리, 폴더)
 - 4가지 접근 지정자: private, protected, public, 디폴트(접근 지정자 생략)

1. 클래스 접근 지정
 - public: 패키지 상관x, 모든 클래스에게 접근 허용
 - 디폴트: 같은 패키지 내의 클래스들에게만 접근 허용

2. 멤버 접근 지정
 - private < 디폴트 < protected < public 순으로 공개 범위 증가
 - public: 모든 클래스들이 접근 가능
 - private: 비공개, 모든 다른 클래스들은 접근 불가
 - protected: 같은 패키지의 모든 클래스들, 자식 클래스들에게 접근 허용
 - 디폴트: 동일 패키지 내의 클래스들에게 허용

--------------------------------------------------------------
4-8 static 멤버
 - static을 붙여 선언한다
  ex) static int m;

1. non-static 멤버와 static 멤버의 차이점
 1) 공간적 특성
  - non: 객체마다 별도 존재(인스턴스 멤버라고 부름)
  - static: 클래스당 하나 존재, 객체 내부가 아닌 클래스 코드가 적재되는 메모리에 생성(클래스 멤버)
 2) 시간적 특성
  - non: 객체 생성 > 멤버 생성 > 멤버 사용 가능 / 객체 삭제 > 멤버 삭제
  - static: 클래스 로딩 > 멤버 생성 > 객체 생성 전에도 사용 가능 > 객체 삭제 > 멤버 삭제x > 프로그램 종료 시 멤버 삭제
 3) 공유의 특성
  - non: 공유 x, 객체 내에 각각 유지
  - static: 동일한 클래스 모든 객체들이 공유

2. static의 활용
 1) 전역 변수와 전역 함수를 만들 때
  - 모든 클래스에서 공유하는 전역 변수나 함수가 필요할 때
 2) 공유 멤버를 만들고자 할 때

3. static 메소드의 제약 조건
 1) static 메소드는 static 멤버에게만 접근 가능
  - static 메소드는 객체 없이도 존재하기에 객체가 있어야 하는 non-static 멤버엔 접근 불가
  - non-static 메소드는 static 멤버에 접근 가능
 2) static 메소드는 this 사용 불가
  - 객체 없이도 존재하기에 객체를 가리키는 this 사용 불가

--------------------------------------------------------------
4-9 final
 - 3군데에 사용
1. final
 1) 클래스
  - 클래스를 상속받을 수 없음을 지정
 2) 메소드
  - 오버라이딩 할 수 없음을 지정
  - 자식 클래스가 부모 클래스의 특정 메소드를 오버라이딩 하지 않고 무조건 상속받게 함
 3) 필드
  - 상수가 됨