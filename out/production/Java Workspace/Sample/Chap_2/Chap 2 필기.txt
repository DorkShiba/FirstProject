명품 자바 프로그래밍 2장

--------------------------------------------------------------
2-1 자바 프로그램의 구조
1. 클래스
 - 가장 기본이자 중요한 것
 - 클래스 안에 변수, 상수, 함수(메서드) 등을 작성한다
 - 클래스 바깥에는 어떤 것도 작성 x
 - "Hello" 클래스 선언 시 코드

public class Hello {
    ...
}

2. 주석문
 - 프로그램 실행에 영향 x
 - 프로그램에 대한 설명이나 특이사항 기록
 - 주석문 예시

// 한 라인 주석, 주석 기호부터 행 끝까지 주석 처리
/*
    여러 라인 주석
*/

3. main() 메서드
 - 이 메서드에서부터 실행을 시작함
 - 반드시 public, static, void 타입으로 선언
 - 한 클래스에 하나만
 - 실행 시작할 클래스에만 있으면 되므로 모든 클래스에 존재할 필요 x
 - main() 메서드 작성 코드

public static void main(String[] args) {
    ...
}

4. 메서드
 - 클래스의 메머 함수
 - sum() 메서드 작성 코드

public static int sum(int n, int m) {
    return n + m;
}

 - sum() 메서드 호출 코드

int i = 20;
s = sum(i, 10);

5. 변수 선언
 - 프로그램 실행 동안 데이터를 저장하는 공간
 1) 지역변수(local variable)
  - 메서드 내에 선언되는 변수
  - 선언된 메서드 내에서만 사용
  - 메서드 실행이 끝나면 소멸
 - 변수 선언 예시

int i;
char a;
int j = 20;  // 변수 j 선언과 동시에 값을 20으로 초기화

6. 문장
 - 모든 문장은 ;로 끝맺음
 - 주석문에는 필요 x

7. 화면 출력
 - System.out.println() or System.out.print() 사용
 - 전자는 출력 후 다음 행 이동, 후자는 이동 x

--------------------------------------------------------------
2-2 식별자
* 식별자: 클래스, 변수, 상수, 메서드 등에 붙이는 이름

1. 식별자 이름 규칙
 - 특수문자 및 공백은 사용 불가, '_', '$'는 예외
 - 한글도 사용 가능
 - if, while 등 자바 언어의 키워드는 사용 불가
 - 첫 번째 문자로 숫자 사용 불가
 - '_', '$'는 첫 번째 문자로 사용 가능하나, 일반적으로 하지 않음
 - 대소문자 구별
 - 길이 제한 x

2. 자바 키워드
 - 자바에서 이미 그 용도가 정해진 단어, 예약어(reserved word)라고도 칭함
 - 식별자로 사용 불가

3. 좋은 이름 붙이는 관습
 1) 목적에 맞는 이름
  ex) 어떠한 수들의 합을 저장하는 변수일 경우
   - s라는 이름보다 sum이라는 이름은 그 용도를 더 쉽게 알 수 있다
 2) 충분히 긴 이름
  ex) 자판기 클래스를 만드는 경우
   - AVM이라는 이름은 선뜻 그 의미를 파악하기 힘듬
   - AutoVendingMachine은 그에 비해 의미를 파악하기 쉽다
 3) 언어의 관습 따르기
  Ⅰ. 클래스 이름
   - 첫 번째 문자는 대문자
   - 여러 단어는 각 단어 첫 번째 문자만 대문자 표시
   ex) AutoVendingMachine, HelloWorld
  Ⅱ. 변수, 메소드 이름
   - 첫 단어는 소문자, 이후 각 단어 첫 번째 문자는 대문자
   - 변수/메소드와 클래스를 쉽게 구별하기 위함
   ex) myAge, isSingle, getAge()
  Ⅲ. 상수 이름
   - 이름 전체를 대문자로
   ex) final double PI = 3.141592;

--------------------------------------------------------------
2-3 자바의 데이터 타입
* 데이터 타입: 자바에서 다룰 수 있는 데이터의 종류, 총 9개

1. 기본 타입: 8개
 - boolean
 - char
 - byte
 - short
 - int
 - long
 - float
 - double

2. 레퍼런스 타입: 1개
 - 한 가지이지만 용도는 다음의 3가지
  1) 배열에 대한 레퍼런스
  2) 클래스(class)에 대한 레퍼런스
  3) 인터페이스(interface)에 대한 레퍼런스

* 레퍼런스
 - 포인터와 비슷한 개념
 - 실제 주소값을 가지진 않음

3. 자바의 기본 타입
 - 정수 저장 타입: byte, short, int, long
 - 실수 저장 타입: float, double
 - 타입마다 크기가 다르기에 다루는 값의 범위에 따라 적절하게 선택
 - 문자 하나는 2바이트의 유니코드로 저장됨
 - 각 타입별 메모리 공간
  - boolean: 1 bit(true or false)
  - char: 2 byte(Unicode)
  - byte: 1 byte(-128 ~ 127)  2^7 = 128
  - short: 2 byte(-32768 ~ 32767)  2^15 = 32768
  - int: 4 byte(-2^31 ~ 2^31 - 1)
  - long: 8 byte(-2^63 ~ 2^63 - 1)
  - float: 4 byte(-3.4E38 ~ 3.4E38)
  - double: 8 byte(-1.7E308 ~ 1.7E308)

4. 문자열
 - 기본 타입에 속하지 않음
 - JDK에서 제공하는 'String' 클래스로 표현
 - 문자열-기본타입 + 연산이 실행되면 기본 타입이 문자열로 바뀌고 둘을 연결한 새로운 문자열 생성

5. 변수와 선언
 - 변수: 데이터를 저장하는 공간
 - 변수 선언 > 해당 타입 크기의 메모리 할당 > 프로그램은 실행 중 값을 쓰고 읽는 공간으로 사용
 - (데이터 타입) (변수 이름);으로 선언
 - 여러개 선언할 시 콤마로 구분
 - = 값을 쓰면 선언과 동시에 초기화 가능

6. 리터럴(literal)
 - 프로그램에 직접 표현한 값
 1) 정수 리터럴
  - 4가지 유형 존재
   ⅰ. 15  (십진수)  0으로 시작 x 수
   ⅱ. 015  (8진수 13)  0으로 시작하는 수
   ⅲ. 0x15  (16진수 21)  0x로 시작하는 수
   ⅳ. 0b0101  (2진수 5)  0b로 시작하는 수
  - int로 자동 컴파일됨
  - long 타입으로 지정할 시 숫자 뒤에 L or l 붙이기
 2) 실수 리터럴
  - 소숫점 형태나 지수 형태로 실수를 표현한 값
  - double 타입으로 자동 처리
  - 실수 뒤에 F or f 붙이면 float, D or d 붙이면 double로 강제 변환
 3) 문자 리터럴
  - 작은 따옴표로 문자를 표현하거나 \u 다음에 문자의 유니코드 값을 써 표현
  - 특수문자 리터럴: 백슬래시 다음에 특수 기호를 붙여서 표현, 이스케이프 시퀀스(escape sequence)라고도 칭함
   - \b: backspace
   - \t: tab
   - \n: line feed(줄 넘김)
   - \f: form feed(현재 활성 위치를 다음 페이지 시작 위치로 옮김)
   - \r: carriage return(현재 활성 위치를 현재 라인의 시작 위치로 옮김)
   - \": 큰 따옴표
   - \': 작은 따옴표
   - \\: 백슬래시
 4) 논리 리터럴과 boolean 타입: true and false only
 5) 그 외
  ⅰ. null 리터럴: 기본 타입에 사용 x, 객체 레퍼런스에 대입
  ⅱ. 문자열 리터럴: 큰따옴표로 표현, String 객체에 저장

* var 키워드
 - 초깃값을 보고 변수의 타입을 추론하기에 선언을 간편하게 함
  ex) var price = 200; (int) / var name = "kitae"; (String)
 - 선언과 동시에 초기화를 하지 않으면 에러

7. 상수
 - final 키워드로 선언
 - 실행 중에 값이 바뀌지 않음

8. 타입 변환
 - 변수, 상수, 리터럴의 타입을 바꾸는 것
 1) 자동 타입 변환
  - 치환문이나 수식 내에서 타입이 일치하지 않을 때 발생
  - 작은 타입을 큰 타입으로 자동 변환
   ex) long m = 25; (int 리터럴을 long 타입으로 자동 변환)
 2) 강제 타입 변환
  - 개발자가 지시하는 것
  - 큰 타입을 작은 타입으로 바꿀 때
  - () 안에 타입을 적어서 실시
   ex) int n = 300; byte b = (byte)n;  // byte는 256까지 저장하므로 300을 256으로 나눈 나머지 저장(44)

--------------------------------------------------------------
2-4 자바에서 키 입력

1. System.in
 - 키보드 장치를 직접 제어
 - 키 입력 받기
 - 표준 입력 스트림 객체
 - 입력된 키를 단순한 바이트 정보로 전달
  -> 이를 문자나 숫자로 변환해야 함
  -> 내가 원하는대로 변환해주는 Scanner 클래스 사용

2. Scanner를 이용한 키 입력
 - 키 입력을 쉽게 하기 위해 자바 패키지에서 제공하는 클래스
 1) Scanner 객체 생성
  - 생성문 예시: Scanner scanner = new Scanner(System.in);
  - 위 객체는 일련의 바이트 정보를 입력받고, 이를 원하는 타입으로 변환해 리턴함
 2) import 문 사용
  - Scanner를 사용하기 위해선 프로그램 맨 앞줄에 import 문이 필요
   ex) import java.util.Scanner;
  - Scanner는 java.util 패키지에 있음
   -> import 문을 통해 Scanner의 경로 표시
 3) Scanner 클래스로 키 입력받기
  - 입력값을 공백 문자를 기준으로 분리해 토큰 단위로 읽는다
   ex) "Kim Seoul 20" 입력 시 -> "Kim", "Seoul", "20"으로 읽음
  - Scanner 클래스의 주요 메소드
   - String next(): 다음 토큰을 문자열로 리턴
   - byte nextByte(): byte로 리턴
   - short nextShort(): short로 리턴
   - 그 외 int, long, float, double, boolean ...
   - String nextLine(): '\n'을 포함하는 한 라인을 읽고 개행문자를 버린 나머지 문자열 리턴
   - void close(): Scanner 사용 종료
   - boolean hasNext(): 토큰이 입력되면 true, 아니면 입력 때가지 무한대기 후 새 입력 들어오면 true 리턴
                        ctrl-z가 입력되면 입력 끝이므로 false 리턴
 4) nextLine()과 next()
  - nextLine()은 공백이 낀 문자열을 입력받음
  - 전자는 Enter 키의 입력을 기다리는 용도로 사용 가능
   -> Enter 만 입력할 때, 빈 문자열 리턴
   -> 후자는 다른 문자열을 기다림(후자는 결코 빈 문자열 리턴 x)
 5) Scanner 객체 닫기
  - scanner.close();로 닫기 가능
  - 닫고나면 다시 사용 불가
  - 닫기 문이 없으면 경고가 뜨나, 실행은 가능

--------------------------------------------------------------
2-5 연산

1. 식과 연산자
 - a + 5 <- 식
  - a, 5: 피연산자(operand)
  - +: 연산자(operator)
 - 연산자 종류
  - 증감: ++, --
  - 산술: +, -, *, /, %
  - 시프트: >>, <<, >>>
  - 비교: >, <, >=, <=, ==, !=
  - 비트: &, |, ^, ~
  - 논리: &&, ||, !, ^
  - 대입: =, +=, -=, *=, /=, &=, ^=, |=, <<=, >>=, >>>=

2. 산술 연산
 - +(덧셈), -(뺄셈), *(곱셈), /(나눗셈), %(나머지)
 - 정수연산에서, /는 몫, %는 나머지

3. 증감 연산
 - ++(1 증가), --(1 감소)
 - ++a 처럼 앞에 붙으면 전위 연산자, 뒤에 붙으면(a--) 후위 연산자
 - 후위 연산자는 a를 쓰고나서 증감, 전위 연산자는 증감하고 나서 변수사용

4. 비교 연산과 논리 연산
 - 비교 연산자: <, >, <=, >=, ==, !=
 - 논리 연산자: !(not), ||(or), &&(and), ^(xor, a != b -> true)

5. 조건 연산
 - 삼항 연산이라고도 함
  - condition ? opr2 : opr3
   -> condition true -> result = opr2
      condition false -> result = opr3

6. 비트 연산
 - 비트 논리 연산: 비트끼리 &&, ||, ^, ! 하는 연산 (&, |, ^, ~(not))
 - 비트 시프트 연산: 비트를 좌우로 이동시키는 연산
 1) 비트 개념
  - bit: 2진수의 한 자리
  - byte: 8개의 비트
   ex) 십진수 10을 1 byte로: 00001010
 2) 비트 논리 연산
  - 비트에서 1을 true, 0을 false로 간주하고 하는 연산
   ex) 01010 & 01101 -> 01000 (각 자릿수에서 하나라도 0이면 0, 둘 다 1이면 1)
       01010 | 01101 -> 01111
       01010 ^ 01101 -> 00111 (두 비트가 같으면 0, 다르면 1)
       ~01010        -> 10101 (1은 0, 0은 1)
 3) 비트 시프트 연산
  - 3개의 연산자(<<, >>, >>>)
  - 새 비트를 좌우 끝에 삽입 (비트의 자리를 이동)
   -> 저장 공간의 크기가 정해져 있음 -> 방향에 따라 끝 자리 비트는 사라짐
  - 연산자 사용법
   1) a >> b
    - a의 각 비트를 우측으로 b번 시프트
    - 최상위 비트는 시프트 전 최상위 비트로
    - 산술적 오른쪽 시프트
   2) a >>> b
    - a의 각 비트를 우측으로 b번 시프트
    - 최상위 비트는 항상 0
    - 논리적 오른쪽 시프트
   3) a << b
    - a의 각 비트를 왼쪽으로 b번 시프트
    - 최하위 비트는 항상 0
    - 산술적 왼쪽 시프트
   * 최상위 비트(MSB)는 이진수의 젤 높은 자리수, 최하위 비트(LSB)는 반대
    ex) 십진수 21 > 8비트 이진수 00010101 / 최상위 비트는 0, 최하위는 1
  - 피연산자는 정수형과 char만 가능
  - >>와 <<는 1비트 할 때마다 나누기 2, 곱하기 2의 효과가 나타난다

--------------------------------------------------------------
2-6 조건문
- 참 거짓에 따라 서로 다른 작업을 수행케 하는 문장
- if 문, if-else 문, switch 문이 있다

1. 단순 if 문
 - 구조 예시
if (condition) {
    ...statement...
}
 - 조건식 결과값은 boolean
  -> 결과가 true면 내부의 실행문 실행
  -> false면 if 문을 벗어남

2. if-else 문
 - 구조 예시
if (condition) {
    ...statement 1...
}
else {
    ...statement 2...
}
 - 조건문 결과가 true면 실행문 1
  -> false면 실행문 2

3. 다중 if-else 문
 - 구조 예시
if (condition 1) {
    ...statement 1...
}
else if (condition 2) {
    ...statement 2...
}
else if (condition 3) {
    ... statement 3...
}
else {
    ...statement 4...
}
 - 위에서부터 조건식을 검사
  -> 참인 경우 해당하는 실행문을 실행

4. switch 문
 - 식의 값에 따라 여러 방향으로 분기하는 경우, 가독성을 위해 사용 가능(반드시 사용은 아님)
 - 구조 예시
switch (statement) {
    case value1:
        statement 1
        break;
    case value2;
        statement 2
        break;
    ...
    default:
        statement 3
}
 - 식을 먼저 계산
  -> 그 결과값과 일치하는 case로 분기
  -> 실행문을 실행 후 break를 만나면 switch 문 탈출
  -> 일치하는 case가 없으면 default 문(생략가능)
 - case의 실행문은 {}로 둘러싸지 않는다
 * 만약 case 문 내에 break 문이 없다면 이를 만날 때까지 아래 case 문의 실행문까지 실행한다
 * case 문의 값은 정수, 문자, 문자열 리터럴만 허용 / 변수나 식은 불가